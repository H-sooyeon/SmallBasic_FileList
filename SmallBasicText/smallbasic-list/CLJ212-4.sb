' Orbit

' Version 0.4

' Copyright 춸 2016 Nonki Takahashi.  The MIT License.

' Last update 2016-06-10

' Program ID CLJ212-4

' Reference:

' 1) NASA/JPL, Keplerian Elements for Approximate Positions of the Major Planets

' http://ssd.jpl.nasa.gov/txt/aprx_pos_planets.pdf

' 2) ?띻茗邏?둖?낋, ?낹椧놴좂發? 嵐갫28嵐? (Chronological Scientific Tables 2016), 2015

' http://www.rikanenpyo.jp

'

GraphicsWindow.Title = "Orbit 0.4"

delay = 30  ' slow

delay = 0   ' fast

pO = "Sa"   ' outer orbit to show

Init()

Form()

lastT_eph = T_start - 1

T_eph = T_start

While "True"

  If lastT_eph <> T_eph Then

    param["playButton"] = playButtonID

    Controls_GetPlayStatus()

    param = "slider=" + sliderID + ";pos=" + T_eph + ";"

    If (status = "PLAYING") Or (lastT_eph = T_start - 1) THen

      param["show"] = "False"

    Else

      param["show"] = "True"

    EndIf

    Controls_MoveSlider()

    ShowDate()

    For iP = 1 To nP

      planet = index[iP]

      CalcPlanetPos()

      DrawPlanet()

    EndFor

    lastT_eph = T_eph

  EndIf

  If mouseDown Then

    If T_start <= T_eph And T_eph < T_end Then

      Controls_TogglePlayStatus()

    EndIf

    param["x"] = dx

    param["y"] = dy

    Controls_UpdateSlider()

    mouseDown = "False"

  EndIf

  If mouseMove Then

    If dragging Then

      param["x"] = mx

      param["y"] = slider[1]["y"]

      Controls_UpdateSlider()

    EndIf

    mouseMove = "False"

  EndIf

  If keyDown Then

    If (key = "Home") And (T_start < T_eph) Then

      T_eph = Math.Max(T_eph - 30, T_start)

    ElseIf (key = "Left") And (T_start < T_eph) Then

      T_eph = Math.Max(T_eph - 1, T_start)

    ElseIf key = "Right" And (T_eph < T_end) Then

      T_eph = Math.Min(T_eph + 1, T_end)

    ElseIf key = "End" And (T_eph < T_end) Then

      T_eph = Math.Min(T_eph + 30, T_end)

    EndIf

    keyDown = "False"

  EndIf

  Program.Delay(delay)

  param["playButton"] = playButtonID

  Controls_GetPlayStatus()

  If status = "PLAYING" Then

    If T_start <= T_eph And T_eph < T_end Then

      T_eph = Math.Min(T_eph + 1, T_end)

    ElseIf T_eph = T_end Then

      param = "playButton=" + playButtonID + ";"

      Controls_PlayPause()

    EndIf

  EndIf

EndWhile

Sub Init

  CRLF = Text.GetCharacter(13) + Text.GetCharacter(10)

  Not = "False=True;True=False;"

  PI = Math.Pi

  dom = "1=31;2=28;3=31;4=30;5=31;6=30;7=31;8=31;9=30;10=31;11=30;12=31;"

  gw = 598

  gh = 428

  GraphicsWindow.Width = gw

  GraphicsWindow.Height = gh

  GraphicsWindow.BackgroundColor = "Black"

  au = "1.4959787E8" ' [km]

  ' tb[][] - planet elements table

  ' Me - Mercury

  ' V - Venus

  ' E - Earth

  ' Ma - Mars

  ' J - Jupter

  ' Sa - Saturn

  ' U - Uranus

  ' N - Neptune

  '

  ' Table 1 1)

  '  Keplerian elements and their rates, with respect to the mean ecliptic

  '  and equinox of J2000, valid for the time-interval 1800 AD - 2050 AD.

  ' ao, ?다 - semi-major axis [au, au/century]

  ' eo, ?단 - eccentricity [ ,  /century]

  ' Io, ?I - inclination [degree, degree/century]

  ' Lo, ?L - mean longitude [degree, degree/century]

  ' ?둂, ?덆? - longitude of perihelion [degree, degree/century]

  ' 풜o, ?덅? - longitude of the ascending node [degree, degree/century]

  tb["Me"] = "ao= 0.38709927;eo= 0.20563593;Io= 7.00497902;Lo=   252.25032350;?둂= 77.45779628;풜o= 48.33076593;"

  tb["Me"] = tb["Me"] + "?다= 0.00000037;?단= 0.00001906;?I=-0.00594749;?L=149472.67411175;?덆?=  0.16047689;?덅?= -0.12534081;"

  tb["V"]  = "ao= 0.72333566;eo= 0.00677672;Io= 3.39467605;Lo=   181.97909950;?둂=131.60246718;풜o= 76.67984255;"

  tb["V"]  = tb["V"]  + "?다= 0.00000390;?단=-0.00004107;?I=-0.00078890;?L= 58517.81538729;?덆?=  0.00268329;?덅?= -0.27769418;"

  tb["E"]  = "ao= 1.00000261;eo= 0.01671123;Io=-0.00001531;Lo=   100.46457166;?둂=102.93768193;풜o=  0.0;"

  tb["E"]  = tb["E"]  + "?다= 0.00000562;?단=-0.00004392;?I=-0.01294668;?L= 35999.37244981;?덆?=  0.32327364;?덅?=  0.0;"

  tb["Ma"] = "ao= 1.52371034;eo= 0.09339410;Io= 1.84969142;Lo=    -4.55343205;?둂=-23.94362959;풜o= 49.55953891;"

  tb["Ma"] = tb["Ma"] + "?다= 0.00001847;?단= 0.00007882;?I=-0.00813131;?L= 19140.30268499;?덆?=  0.44441088;?덅?= -0.29257343;"

  tb["J"]  = "ao= 5.20288700;eo= 0.04838624;Io= 1.30439695;Lo=    34.39644051;?둂= 14.72847983;풜o=100.47390909;"

  tb["J"]  = tb["J"]  + "?다=-0.00011607;?단=-0.00013253;?I=-0.00183714;?L=  3034.74612775;?덆?=  0.21252668;?덅?=  0.20469106;"

  tb["Sa"] = "ao= 9.53667594;eo= 0.05386179;Io= 2.48599187;Lo=    49.95424423;?둂= 92.59887831;풜o=113.66242448;"

  tb["Sa"] = tb["Sa"] + "?다=-0.00125060;?단=-0.00050991;?I= 0.00193609;?L=  1222.49362201;?덆?= -0.41897216;?덅?= -0.28867794;"

  tb["U"]  = "ao=19.18916464;eo= 0.04725744;Io= 0.77263783;Lo=   313.23810451;?둂=170.95427630;풜o= 74.01692503;"

  tb["U"]  = tb["U"]  + "?다=-0.00196176;?단=-0.00004397;?I=-0.00242939;?L=   428.48202785;?덆?=  0.40805281;?덅?=  0.04240589;"

  tb["N"]  = "ao=30.06992276;eo= 0.00859048;Io= 1.77004347;Lo=   -55.12002969;?둂= 44.96476227;풜o=131.78422574;"

  tb["N"]  = tb["N"]  + "?다= 0.00026291;?단= 0.00005105;?I= 0.00035372;?L=   218.45945325;?덆?= -0.32241464;?덅?= -0.00508664;"

  ' r - equatorial radius of the planet [km] 2)

  ' color - color for the planet

  tb["Su"] = "r=696000;color=#FFFFCC;"

  tb["Me"] = tb["Me"] + "r= 2440;color=LightGray;"

  tb["V"]  = tb["V"]  + "r= 6052;color=CornSilk;"

  tb["E"]  = tb["E"]  + "r= 6378;color=#336699;"

  tb["Ma"] = tb["Ma"] + "r= 3396;color=#FF6633;"

  tb["J"]  = tb["J"]  + "r=71492;color=Tan;"

  tb["Sa"] = tb["Sa"] + "r=60268;color=DarkKhaki;"

  tb["U"]  = tb["U"]  + "r=25559;color=SkyBlue;"

  tb["N"]  = tb["N"]  + "r=24764;color=RoyalBlue;"

  nP = Array.GetItemCount(tb)

  index = Array.GetAllIndices(tb)

  For iP = 1 To nP

    If index[iP] = pO Then

      nP = iP

    EndIf

  EndFor

EndSub

Sub Form

  xo = gw / 2

  yo = gh / 2 - 30

  rO = yo - 10

  GraphicsWindow.BrushColor = "LightGray"

  txtDate = Shapes.AddText("Date")

  Shapes.Move(txtDate, 50, gh - 30)

  DrawSun()

  date = "1900/01/01"

  DateToJD()

  T_start = jd

  date = "2100/01/01"

  DateToJD()

  T_end = jd

  param = "x=" + 10 + ";y=" + (gh - 45) + ";width=" + (gw - 20) + ";"

  param["start"] = T_start

  param["end"] = T_end

  Controls_AddSlider()

  sliderID = id

  param = "x=" + 10 + ";y=" + (gh - 30) + ";"

  Controls_AddPlayButton()

  playButtonID = id

EndSub

Sub CalcPlanetPos

  ' param planet

  ' param T_eph

  ' In order to obtain the coordinates of one of the planets as a given Julian Ephemeris Date, T_eph,

  ' 1. Compute the value of each of that planet's six elements: a = ao + ?다 T,, etc., where T,

  '    the number of centuries past J2000.0, is T = (T_eph - 2451545.0) / 36525.

  T = (T_eph - 2451545.0) / 36525

  a = tb[planet]["ao"] + tb[planet]["?다"] * T

  e = tb[planet]["eo"] + tb[planet]["?단"] * T

  I = Math.Remainder(tb[planet]["Io"] + tb[planet]["?I"] * T, 360)

  L = Math.Remainder(tb[planet]["Lo"] + tb[planet]["?L"] * T, 360)

  ?? = Math.Remainder(tb[planet]["?둂"] + tb[planet]["?덆?"] * T, 360)

  풜 = Math.Remainder(tb[planet]["풜o"] + tb[planet]["?덅?"] * T, 360)

  ' 2. Compute the argument of perihelion, ??, and the mean anomaly, M :

  '    ?? = ?? - 풜 ; M = L - ??

  ?겷 = ?? - 풜

  M = Math.Remainder(L - ?? + 180, 360) - 180

  '  M = L - ??

  ' 3. Modulus the mean anomaly so that -180춿 ?곥 M < +180춿 and then obtain the eccentric

  '     anomaly, E, from the solution of Kepler's equation (see below):

  '    M = E - e_deg sin E,

  '    where e_deg = 180/? e = 57.29578 e.

  e_deg = Math.GetDegrees(e)

  _M = Math.GetRadians(M)

  EA = M + e_deg * Math.Sin(_M)

  tol = "1E-6"

  Calc3Equ()

  While Math.Abs(?EA) > tol

    Calc3Equ()

  EndWhile

  ' 4. Compute the planet's heliocentric coodinates in its orbital plane, r', with the x'-axis

  '    aligned from the focus to the perihelion:

  '    x' = a(cos E - e) ; y' = a  ?갴(1 - e^2) sin E ; z' = 0

  _EA = Math.GetRadians(EA)

  xh = a * (Math.Cos(_EA) - e)

  yh = a * Math.SquareRoot(1 - e * e) * Math.Sin(_EA)

  zh = 0

  ' 5. Compute the coordinates, r_ecl, in the J2000 ecliptic plane, with the x-axis aligned

  '    toward the equinox:

  '    r_ecl = _M r' ?고 _Rz (-풜) _Rx (-I) _Rz (-??) r'

  '    so that

  '    x_ecl = (cos ?? cos 풜 - sin ?? sin 풜 cos I) x' + (- sin ?? cos 풜 - cos ?? sin 풜 cos I) y' 

  '    y_ecl = (cos ?? sin 풜 + sin ?? cos 풜 cos I) x' + (- sin ?? sin 풜 + cos ?? cos 풜 cos I) y'

  '    z_ecl = (sin ?? sin I) x' + (cos ?? sin I) y'

  _?겷 = Math.GetRadians(?겷)

  _풜 = Math.GetRadians(풜)

  _I = Math.GetRadians(I)

  x_ecl = (Math.Cos(_?겷) * Math.Cos(_풜) - Math.Sin(_?겷) * Math.Sin(_풜) * Math.Cos(_I)) * xh

  x_ecl = x_ecl + (-Math.Sin(_??p) * Math.Cos(_풜) - Math.Cos(_?겷) * Math.Sin(_풜) * Math.Cos(_I)) * yh

  y_ecl = (Math.Cos(_?겷) * Math.Sin(_풜) + Math.Sin(_?겷) * Math.Cos(_풜) * Math.Cos(_I)) * xh

  y_ecl = y_ecl + (-Math.Sin(_?겷) * Math.Sin(_풜) + Math.Cos(_?겷) * Math.Cos(_풜) * Math.Cos(_I)) * yh

  z_ecl = (Math.Sin(_?겷) * Math.Sin(_I)) * xh

  z_ecl = z_ecl + (Math.Cos(_?겷) * Math.Sin(_I)) * yh

  ' 6. If desired, obtain the equatorial coodinates in the "ICRF" or "J2000 frame", r_eq :

  '    x_eq = x_ecl

  '    y_eq = + cos 풧 y_ecl - sin 풧 z_ecl

  '    z_eq = + sin 풧 y_ecl + cos 풧 z_ecl

  '    wherre the obliquility at J2000 is 풧 = 23춿.43928.

EndSub

Sub Calc3Equ

  ' Solution of Kepler's Equation, M = E - e_deg sin E

  ' Given the mean anomaly, M, and the eccentricity, e_deg, both in degrees, start with

  '    E0 = M + e_deg sin M

  ' and iterate the following three equations, with n = 0, 1, 2, ..., until |?E| ?곥 tol (nothing

  ' that e_deg is in degrees; e is in radians):

  '    ?M = M - (En - e_deg sin En) ; ?E = ?M / (1 - e cos En) ; En+1 = En + ?E.

  ' For the aproximate formulae in this present context, tol = 10^-6 degrees in sufficient.

  _EA = Math.GetRadians(EA)

  ?M = M - (EA - e_deg * Math.Sin(_EA))

  ?EA = ?M / (1 - e * Math.Cos(_EA))

  EA = EA + ?EA

EndSub

Sub DrawPlanet

  ' param planet - planet index

  ' param a - semi-mejor axis [au]

  ' param e - eccenricity

  ' param ?? - longitude of perihelion [degree]

  _?? = Math.GetRadians(??)

  a = a / tb[pO]["ao"] * rO                   ' semi-major axis

  b = Math.SquareRoot(1 - e * e) * a          ' semi-minor axis

  If tb[planet]["orbit"] = "" Then

    GraphicsWindow.PenWidth = 1

    GraphicsWindow.PenColor = "#333333"

    GraphicsWindow.BrushColor = "Transparent"

    tb[planet]["orbit"] = Shapes.AddEllipse(2 * a, 2 * b)

    xc = xo + e * a * Math.Cos(_?? + PI)

    yc = yo - e * a * Math.Sin(_?? + PI)

    x = xc - a

    y = yc - b

    Shapes.Move(tb[planet]["orbit"], x, y)

    Shapes.Rotate(tb[planet]["orbit"], -??)

  EndIf

  GraphicsWindow.PenColor = "Transparent"

  GraphicsWindow.BrushColor = tb[planet]["color"]

  If nP < 5 Then

    r = tb[planet]["r"] / (tb[pO]["ao"] * au) * rO * 500

  Else

    r = 2

  EndIf

  If tb[planet]["planet"] = "" Then

    tb[planet]["planet"] = Shapes.AddEllipse(2 * r, 2 * r)

  EndIf

  x = xo + x_ecl / tb[pO]["ao"] * rO 

  y = yo - y_ecl / tb[pO]["ao"] * rO

  Shapes.Move(tb[planet]["planet"], x - r / 2, y - r / 2)

EndSub

Sub DrawSun

  If nP < 5 Then

    r = tb["Su"]["r"] / (tb[pO]["ao"] * au) * rO * 10

  Else

    r = 2.5

  EndIf

  GraphicsWindow.BrushColor = tb["Su"]["color"]

  GraphicsWindow.FillEllipse(xo - r, yo - r, 2 * r, 2 * r)

EndSub

Sub DateToJD

  ' param date - date formatted as YYYY/MM/DD

  ' return jd - Julian Day [day]

  s1 = Text.GetIndexOf(date, "/")

  year = Text.ConvertToUpperCase(Text.GetSubText(date, 1, s1 - 1))

  bc = Text.GetIndexOf(year, "BC")

  If 0 < bc Then

    year = Text.GetSubText(year, 1, bc - 1) + Text.GetSubTextToEnd(year, bc + 2)

    year = -(year - 1)

  EndIf

  s2 = Text.GetIndexOf(Text.GetSubTextToEnd(date, s1 + 1), "/") + s1

  month = Text.GetSubText(date, s1 + 1, s2 - s1 - 1)

  day = Text.GetSubTextToEnd(date, s2 + 1)

  jc = "False"  ' Julian calendar

  If year < 1582 Then

    jc = "True"

  ElseIf year = 1582 Then

    If month < 10 Then

      jc = "True"

    ElseIf month = 10 Then

      If day <= 4 Then

        jc = "True"

      ElseIf 4 < day And day < 15 Then

        TextWindow.WriteLine("ERROR:Invalid date " + date)

      EndIf

    EndIf

  EndIf

  If jc Then  ' Julian calendar

    y4801BC = year + 4800

    d4801BC = Math.Ceiling(y4801BC * 365.25)

    If Math.Remainder(y4801BC, 4) = 0 Then

      dom[2] = 29

    Else

      dom[2] = 28

    EndIf

    For mm = 1 To month - 1

      d4801BC = d4801BC + dom[mm]

    EndFor

    d4801BC = d4801BC + day - 1

    jd = d4801BC - 32142.5

  Else        ' Gregorian calendar

    y1200 = year - 1200

    nol = Math.Ceiling(y1200 / 4) - Math.Ceiling(y1200 / 100) + Math.Ceiling(y1200 / 400)  ' number of leap year

    d1200 = y1200 * 365 + nol

    If Math.Remainder(y1200, 4) = 0 And Math.Remainder(y1200, 100) <> 0 Or Math.Remainder(y1200, 400) = 0 Then

      dom[2] = 29

    Else

      dom[2] = 28

    EndIf

    For mm = 1 To month - 1

      d1200 = d1200 + dom[mm]

    EndFor

    d1200 = d1200 + day - 1

    jd = d1200 + 2159350.5

  EndIf

EndSub

Sub JDToDate

  ' param jd - Julian Day [day] ?곦 -32142.5 (-4801 BC/01/01)

  ' return date - date formatted as YYYY/MM/DD

  If jd < 2299160.5 Then  ' Julian calendar

    d4801BC = Math.Floor(jd + 0.5) - 0.5 + 32142.5

    year = (-4800) + Math.Floor(d4801BC / 365.25)

    If Math.Remainder(year, 4) = 0 Then

      dom[2] = 29

    Else

      dom[2] = 28

    EndIf

    day = Math.Floor(Math.Remainder(d4801BC, 365.25))

    If year < 1 Then

      year = (Math.Abs(year) + 1) + " BC" 

    EndIF

  Else                    ' Gregorian calendar

    d1200 = Math.Floor(jd + 0.5) - 0.5 - 2159350.5

    y1200 = Math.Floor(d1200 / 365.2425)

    year = 1200 + y1200

    If Math.Remainder(year, 4) = 0 And Math.Remainder(year, 100) <> 0 Or Math.Remainder(year, 400) = 0 Then

      dom[2] = 29

    Else

      dom[2] = 28

    EndIf

    nol = Math.Ceiling(y1200 / 4) - Math.Ceiling(y1200 / 100) + Math.Ceiling(y1200 / 400)  ' number of leap year

    day = d1200 - nol

    day = Math.Floor(Math.Remainder(d1200 - nol, 365))

  EndIf

  For mm = 1 To 12

    If day < dom[mm] Then

      month = mm

      mm = 12  ' exit For

    Else

      day = day - dom[mm]

    EndIf

  EndFor

  If month < 10 Then

    month = Text.Append(0, month * 1)

  EndIf

  day = day + 1

  If day < 10 Then

    day = Text.Append(0, day * 1)

  EndIf

  date = year + "/" + month + "/" + day

EndSub

Sub ShowDate

  ' param T_eph - Julian Day [day] ?곦 -32142.5 (-4801 BC/01/01)

  jd = T_eph

  JDToDate()

  Shapes.SetText(txtDate, date)

EndSub

Sub Controls_AddSlider

  ' param["x"] - left x coordinate

  ' param["y"] - top y coordinate

  ' param["width"] - width

  ' param["start"] - start value

  ' param["end"] - end value

  ' return id - slider ID

  Stack.PushValue("local", GraphicsWindow.BrushColor)

  Stack.PushValue("local", GraphicsWindow.PenWidth)

  sl = param

  GraphicsWindow.BrushColor = "Gray"

  GraphicsWindow.FillRectangle(sl["x"], sl["y"], sl["width"], 4)

  GraphicsWindow.PenWidth = 0

  GraphicsWindow.BrushColor = "Red"

  sl["slider"] = Shapes.AddEllipse(10, 10)

  Shapes.HideShape(sl["slider"])

  sl["pos"] = sl["start"]

  sl["play"] = "False"

  numSlider = numSlider + 1

  slider[numSlider] = sl 

  id = "Slider" + numSlider

  GraphicsWindow.PenWidth = Stack.PopValue("local")

  GraphicsWindow.BrushColor = Stack.PopValue("local")

EndSub

Sub Controls_MoveSlider

  ' param["slider"] - slider ID

  ' param["pos"] - slider position

  ' param["show"] - "True" to show slider

  iSlider = Text.GetSubTextToEnd(param["slider"], 7)

  sl = slider[iSlider]

  If sl["start"] <= param["pos"] And param["pos"] <= sl["end"] Then

    sl["pos"] = param["pos"]

    If sl["start"] < sl["pos"] Then

      Stack.PushValue("local", GraphicsWindow.BrushColor)

      width = sl["width"] * (sl["pos"] - sl["start"]) / (sl["end"] - sl["start"])

      GraphicsWindow.BrushColor = "Red"

      GraphicsWindow.FillRectangle(sl["x"], sl["y"], width, 4)

      GraphicsWindow.BrushColor = "Gray"

      GraphicsWindow.FillRectangle(sl["x"] + width, sl["y"], sl["width"] - width, 4)

      GraphicsWindow.BrushColor = Stack.PopValue("local")

    EndIf

    slider[iSlider] = sl

    If param["show"] Then

      width = sl["width"] * (sl["pos"] - sl["start"]) / (sl["end"] - sl["start"])

      Shapes.Move(sl["slider"], sl["x"] + width - 5, sl["y"] + 2 - 5)

      Shapes.ShowShape(sl["slider"])

    Else

      Shapes.HideShape(sl["slider"])

    EndIf

  EndIF

EndSub

Sub Controls_UpdateSlider

  ' param["x"] - x coodinate

  ' param["y"] - y coodinate

  _x = param["x"]

  _y = param["y"] 

  For iSlider = 1 To numSlider

    sl = slider[iSlider]

    x1 = sl["x"]

    y1 = sl["y"] + 2 - 5

    x2 = sl["x"] + sl["width"]

    y2 = sl["y"] + 2 + 5

    If x1 <= _x And _x <= x2 And y1 <= _y And _y <= y2 Then

      dragging = "True"

      param["slider"] = "Slider" + iSlider

      param["pos"] = sl["start"] + (sl["end"] - sl["start"]) * (_x - x1) / (x2 - x1)

      param["show"] = "True"

      Controls_MoveSlider()

      T_eph = param["pos"]

      ShowDate()

    EndIf

  EndFor

EndSub

Sub Controls_AddPlayButton

  ' param["x"] - left x coodinate

  ' param["y"] - top y coodinate

  ' return id - play button ID

  Stack.PushValue("local", GraphicsWindow.BrushColor)

  Stack.PushValue("local", GraphicsWindow.PenWidth)

  pb = param

  GraphicsWindow.PenWidth = 0

  GraphicsWindow.BrushColor = "LightGray"

  pb["play"] = Shapes.AddTriangle(0, 0, 0, 16, 16, 8)

  Shapes.Move(pb["play"], pb["x"], pb["y"])

  pb["pause1"] = Shapes.AddRectangle(5, 16)

  Shapes.Move(pb["pause1"], pb["x"], pb["y"])

  Shapes.HideShape(pb["pause1"])

  pb["pause2"] = Shapes.AddRectangle(5, 16)

  Shapes.Move(pb["pause2"], pb["x"] + 11, pb["y"])

  Shapes.HideShape(pb["pause2"])

  numPlayButton = numPlayButton + 1

  playButton[numPlayButton] = pb

  id = "PlayButton" + numPlayButton

  GraphicsWindow.PenWidth = Stack.PopValue("local")

  GraphicsWindow.BrushColor = Stack.PopValue("local")

  GraphicsWindow.MouseDown = OnMouseDown

  GraphicsWindow.MouseUp = OnMouseUp

  GraphicsWindow.MouseMove = OnMouseMove

  GraphicsWindow.KeyDown = OnKeyDown

EndSub

Sub OnMouseDown

  dx = GraphicsWindow.MouseX

  dy = GraphicsWindow.MouseY

  mouseDown = "True"

EndSub

Sub OnMouseMove

  mx = GraphicsWindow.MouseX

  my = GraphicsWindow.MouseY

  mouseMove = "True"

EndSub

Sub OnMouseUp

  dragging = "False"

EndSub

Sub OnKeyDown

  key = GraphicsWindow.LastKey

  keyDown = "True"

EndSub

Sub Controls_PlayStart

  ' param["playButton"] - play button ID

  iPlayButton = Text.GetSubTextToEnd(param["playButton"], 11)

  pb = playButton[iPlayButton]

  Shapes.HideShape(pb["play"])

  Shapes.ShowShape(pb["pause1"])

  Shapes.ShowShape(pb["pause2"])

  pb["playing"] = "True"

  playButton[iPlayButton] = pb

EndSub

Sub Controls_PlayPause

  ' param["playButton"] - play button ID

  iPlayButton = Text.GetSubTextToEnd(param["playButton"], 11)

  pb = playButton[iPlayButton]

  Shapes.HideShape(pb["pause1"])

  Shapes.HideShape(pb["pause2"])

  Shapes.ShowShape(pb["play"])

  pb["playing"] = "False"

  playButton[iPlayButton] = pb

EndSub

Sub Controls_GetPlayStatus

  iPlayButton = Text.GetSubTextToEnd(param["playButton"], 11)

  pb = playButton[iPlayButton]

  If pb["playing"] Then

    status = "PLAYING"

  Else

    status = "PAUSE"

  EndIf

EndSub

Sub Controls_TogglePlayStatus

  For iPlayButton = 1 To numPlayButton

    pb = playButton[iPlayButton]

    x1 = pb["x"]

    y1 = pb["y"]

    x2 = pb["x"] + 15

    y2 = pb["y"] + 15

    If x1 <= dx And dx <= x2 And y1 <= dy And dy <= y2 Then

      param["playButton"] = "PlayButton" + iPlayButton

      If pb["playing"] Then

        Controls_PlayPause()

      Else

        Controls_PlayStart()

      EndIf

    EndIf

  EndFor

EndSub


