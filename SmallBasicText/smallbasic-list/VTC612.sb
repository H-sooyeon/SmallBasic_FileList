///WORKSPACE MANAGEMENT



**PROCEDURE DEFINITION



>>TO procname :input1 :input2 ...				(special form)



	command.  Prepares Logo to accept a procedure definition.  The

	procedure will be named "procname" and there must not already

	be a procedure by that name.  The inputs will be called "input1"

	etc.  Any number of inputs are allowed, including none.  Names

	of procedures and inputs are case-insensitive.



	Unlike every other Logo procedure, TO takes as its inputs the

	actual words typed in the instruction line, as if they were

	all quoted, rather than the results of evaluating expressions

	to provide the inputs.  (That's what "special form" means.)



	This version of Logo allows variable numbers of inputs to a

	procedure.  After the procedure name come four kinds of

	things, *in this order*:



	    1.   0 or more REQUIRED inputs    :FOO :FROBOZZ

	    2.   0 or more OPTIONAL inputs    [:BAZ 87] [:THINGO 5+9]

	    3.   0 or 1 REST input            [:GARPLY]

	    4.   0 or 1 DEFAULT number        5



	Every procedure has a MINIMUM, DEFAULT, and MAXIMUM

	number of inputs.  (The latter can be infinite.)



	The MINIMUM number of inputs is the number of required inputs,

	which must come first.  A required input is indicated by the



			:inputname



	notation.



	After all the required inputs can be zero or more optional inputs,

	each of which is represented by the following notation:



			[:inputname default.value.expression]



	When the procedure is invoked, if actual inputs are not supplied

	for these optional inputs, the default value expressions are

	evaluated to set values for the corresponding input names.  The

	inputs are processed from left to right, so a default value

	expression can be based on earlier inputs.  Example:



			to proc :inlist [:startvalue first :inlist]



	If the procedure is invoked by saying



			proc [a b c]



	then the variable INLIST will have the value [A B C] and the

	variable STARTVALUE will have the value A.  If the procedure

	is invoked by saying



			(proc [a b c] "x)



	then INLIST will have the value [A B C] and STARTVALUE will

	have the value X.



	After all the required and optional input can come a single "rest"

	input, represented by the following notation:



			[:inputname]



	This is a rest input rather than an optional input because there

	is no default value expression.  There can be at most one rest

	input.  When the procedure is invoked, the value of this inputname

	will be a list containing all of the actual inputs provided that

	were not used for required or optional inputs.  Example:



			to proc :in1 [:in2 "foo] [:in3 "baz] [:in4]



	If this procedure is invoked by saying



			proc "x



	then IN1 has the value X, IN2 has the value FOO, IN3 has the value

	BAZ, and IN4 has the value [] (the empty list).  If it's invoked

	by saying



			(proc "a "b "c "d "e)



	then IN1 has the value A, IN2 has the value B, IN3 has the value C,

	and IN4 has the value [D E].



	The MAXIMUM number of inputs for a procedure is infinite if a

	rest input is given; otherwise, it is the number of required

	inputs plus the number of optional inputs.



	The DEFAULT number of inputs for a procedure, which is the number

	of inputs that it will accept if its invocation is not enclosed

	in parentheses, is ordinarily equal to the minimum number.  If

	you want a different default number you can indicate that by

	putting the desired default number as the last thing on the

	TO line.  example:



			to proc :in1 [:in2 "foo] [:in3] 3



	This procedure has a minimum of one input, a default of three

	inputs, and an infinite maximum.



	Logo responds to the TO command by entering procedure definition

	mode.  The prompt character changes from "?" to ">" and whatever

	instructions you type become part of the definition until you

	type a line containing only the word END.



>>DEFINE procname text



	command.  Defines a procedure with name "procname" and text "text".

	If there is already a procedure with the same name, the new

	definition replaces the old one.  The text input must be a list

	whose members are lists.  The first member is a list of inputs;

	it looks like a TO line but without the word TO, without the

	procedure name, and without the colons before input names.  In

	other words, the members of this first sublist are words for

	the names of required inputs and lists for the names of optional

	or rest inputs.  The remaining sublists of the text input make

	up the body of the procedure, with one sublist for each instruction

	line of the body.  (There is no END line in the text input.)

	It is an error to redefine a primitive procedure unless the variable

	REDEFP has the value TRUE.



>>TEXT procname



	outputs the text of the procedure named "procname" in the form

	expected by DEFINE: a list of lists, the first of which describes

	the inputs to the procedure and the rest of which are the lines of

	its body.  The text does not reflect formatting information used

	when the procedure was defined, such as continuation lines and

	extra spaces.



>>FULLTEXT procname



	outputs a representation of the procedure "procname" in which

	formatting information is preserved.  If the procedure was defined

	with TO, EDIT, or LOAD, then the output is a list of words.  Each

	word represents one entire line of the definition in the form

	output by READWORD, including extra spaces and continuation lines.

	The last member of the output represents the END line.  If the

	procedure was defined with DEFINE, then the output is a list of

	lists.  If these lists are printed, one per line, the result will

	look like a definition using TO.  Note: the output from FULLTEXT

	is not suitable for use as input to DEFINE!



>>COPYDEF newname oldname



	command.  Makes "newname" a procedure identical to "oldname".

	The latter may be a primitive.  If "newname" was already defined,

	its previous definition is lost.  If "newname" was already a

	primitive, the redefinition is not permitted unless the variable

	REDEFP has the value TRUE.



	Note: dialects of Logo differ as to the order of inputs to COPYDEF.

	This dialect uses "MAKE order," not "NAME order."





**VARIABLE DEFINITION



>>MAKE varname value



	command.  Assigns the value "value" to the variable named "varname",

	which must be a word.  Variable names are case-insensitive.  If a

	variable with the same name already exists, the value of that

	variable is changed.  If not, a new global variable is created.



>>NAME value varname					(library procedure)



	command.  Same as MAKE but with the inputs in reverse order.



>>LOCAL varname

LOCAL varnamelist

(LOCAL varname1 varname2 ...)



	command.  Accepts as inputs one or more words, or a list of

	words.  A variable is created for each of these words, with

	that word as its name.  The variables are local to the

	currently running procedure.  Logo variables follow dynamic

	scope rules; a variable that is local to a procedure is

	available to any subprocedure invoked by that procedure.

	The variables created by LOCAL have no initial value; they

	must be assigned a value (e.g., with MAKE) before the procedure

	attempts to read their value.



>>LOCALMAKE varname value				(library procedure)



	command.  Makes the named variable local, like LOCAL, and

	assigns it the given value, like MAKE.



>>THING varname

:quoted.varname



	outputs the value of the variable whose name is the input.

	If there is more than one such variable, the innermost local

	variable of that name is chosen.  The colon notation is an

	abbreviation not for THING but for the combination



				thing "



	so that :FOO means THING "FOO.



>>GLOBAL varname

GLOBAL varnamelist

(GLOBAL varname1 varname2 ...)



	command.  Accepts as inputs one or more words, or a list of

	words.  A global variable is created for each of these words, with

	that word as its name.  The only reason this is necessary is that

	you might want to use the "setter" notation SETXYZ for a variable

	XYZ that does not already have a value; GLOBAL "XYZ makes that legal.

	Note: If there is currently a local variable of the same name, this

	command does *not* make Logo use the global value instead of the

	local one.





**PROPERTY LISTS



>>Note: Names of property lists are always case-insensitive.  Names of

individual properties are case-sensitive or case-insensitive depending

on the value of CASEIGNOREDP, which is TRUE by default.



In principle, every possible name is the name of a property list, which

is initially empty.  So Logo never gives a "no such property list" error,

as it would for undefined procedure or variable names.  But the primitive

procedures that deal with "all" property lists (CONTENTS, PLISTS, etc.)

list only nonempty ones.  To "erase" a property list (see ERASE below)

means to make it empty, removing all properties from it.



>>PPROP plistname propname value



	command.  Adds a property to the "plistname" property list

	with name "propname" and value "value".



>>GPROP plistname propname



	outputs the value of the "propname" property in the "plistname"

	property list, or the empty list if there is no such property.



>>REMPROP plistname propname



	command.  Removes the property named "propname" from the

	property list named "plistname".



>>PLIST plistname



	outputs a list whose odd-numbered members are the names, and

	whose even-numbered members are the values, of the properties

	in the property list named "plistname".  The output is a copy

	of the actual property list; changing properties later will not

	magically change a list output earlier by PLIST.





**PREDICATES



>>PROCEDUREP name

PROCEDURE? name



	outputs TRUE if the input is the name of a procedure.



>>PRIMITIVEP name

PRIMITIVE? name



	outputs TRUE if the input is the name of a primitive procedure

	(one built into Logo).  Note that some of the procedures

	described in this document are library procedures, not primitives.



>>DEFINEDP name

DEFINED? name



	outputs TRUE if the input is the name of a user-defined procedure,

	including a library procedure.



>>NAMEP name

NAME? name



	outputs TRUE if the input is the name of a variable.



>>PLISTP name

PLIST? name



	outputs TRUE if the input is the name of a *nonempty* property list.

	(In principle every word is the name of a property list; if you haven't

	put any properties in it, PLIST of that name outputs an empty list,

	rather than giving an error message.)





**QUERIES



Note:  All procedures whose input is indicated as "contentslist" will

accept a single word (taken as a procedure name), a list of words (taken

as names of procedures), or a list of three lists as described under

the CONTENTS command above.



>>CONTENTS



	outputs a "contents list," i.e., a list of three lists containing

	names of defined procedures, variables, and property lists

	respectively.  This list includes all unburied named items in

	the workspace.



>>BURIED



	outputs a contents list including all buried named items in

	the workspace.



>>TRACED



	outputs a contents list including all traced named items in

	the workspace.



>>STEPPED



	outputs a contents list including all stepped named items in

	the workspace.



>>PROCEDURES



	outputs a list of the names of all unburied user-defined procedures

	in the workspace.  Note that this is a list of names, not a

	contents list.  (However, procedures that require a contents list

	as input will accept this list.)



>>PRIMITIVES



	outputs a list of the names of all primitive procedures

	in the workspace.  Note that this is a list of names, not a

	contents list.  (However, procedures that require a contents list

	as input will accept this list.)



>>NAMES



	outputs a contents list consisting of an empty list (indicating

	no procedure names) followed by a list of all unburied variable

	names in the workspace.



>>PLISTS



	outputs a contents list consisting of two empty lists (indicating

	no procedures or variables) followed by a list of all unburied

	nonempty property lists in the workspace.



>>NAMELIST varname					(library procedure)

NAMELIST varnamelist



	outputs a contents list consisting of an empty list followed by

	a list of the name or names given as input.  This is useful in

	conjunction with workspace control procedures that require a contents

	list as input.



>>PLLIST plname						(library procedure)

PLLIST plnamelist



	outputs a contents list consisting of two empty lists followed by

	a list of the name or names given as input.  This is useful in

	conjunction with workspace control procedures that require a contents

	list as input.



>>ARITY procedurename



	outputs a list of three numbers: the minimum, default, and maximum

	number of inputs for the procedure whose name is the input.  It is an

	error if there is no such procedure.  A maximum of -1 means that the

	number of inputs is unlimited.



>>NODES



	outputs a list of two numbers.  The first represents the number of

	nodes of memory currently in use.  The second shows the maximum

	number of nodes that have been in use at any time since the last

	invocation of NODES.  (A node is a small block of computer memory

	as used by Logo.  Each number uses one node.  Each non-numeric

	word uses one node, plus some non-node memory for the characters

	in the word.  Each array takes one node, plus some non-node

	memory, as well as the memory required by its elements.  Each

	list requires one node per element, as well as the memory within

	the elements.)  If you want to track the memory use of an

	algorithm, it is best if you invoke GC at the beginning of each

	iteration, since otherwise the maximum will include storage that

	is unused but not yet collected.





**INSPECTION



>>PRINTOUT/PO contentslist



	command.  Prints to the write stream the definitions of all

	procedures, variables, and property lists named in the input

	contents list.



>>POALL							(library procedure)



	command.  Prints all unburied definitions in the workspace.

	Abbreviates PO CONTENTS.



>>POPS							(library procedure)



	command.  Prints the definitions of all unburied procedures in

	the workspace.  Abbreviates PO PROCEDURES.



>>PONS							(library procedure)



	command.  Prints the definitions of all unburied variables in

	the workspace.  Abbreviates PO NAMES.



>>POPLS							(library procedure)



	command.  Prints the contents of all unburied nonempty property

	lists in the workspace.  Abbreviates PO PLISTS.



>>PON varname						(library procedure)

PON varnamelist



	command.  Prints the definitions of the named variable(s).

	Abbreviates PO NAMELIST varname(list).



>>POPL plname						(library procedure)

POPL plnamelist



	command.  Prints the definitions of the named property list(s).

	Abbreviates PO PLLIST plname(list).



>>POT contentslist



	command.  Prints the title lines of the named procedures and

	the definitions of the named variables and property lists.

	For property lists, the entire list is shown on one line

	instead of as a series of PPROP instructions as in PO.



>>POTS							(library procedure)



	command.  Prints the title lines of all unburied procedures

	in the workspace.  Abbreviates POT PROCEDURES.











///CONTROL STRUCTURES



>>Note: in the following descriptions, an "instructionlist" can be a list

or a word.  In the latter case, the word is parsed into list form before

it is run.  Thus, RUN READWORD or RUN READLIST will work.  The former is

slightly preferable because it allows for a continued line (with ~) that

includes a comment (with ;) on the first line.



A "tf" input must be the word TRUE, the word FALSE, or a list.  If it's a

list, then it must be a Logo expression, which will be evaluated to produce

a value that must be TRUE or FALSE.  The comparisons with TRUE and FALSE

are always case-insensitive.



A runlist can consist of either a single expression (that produces a value)

or zero or more instructions (that do something, rather than output a value),

depending on the context:



	PRINT IFELSE :X<0 ["NEGATIVE] ["POSITIVE]  ; one value in each case

	REPEAT 4 [PRINT "A PRINT "B]  ; two instructions





>>RUN instructionlist



	command or operation.  Runs the Logo instructions in the input

	list; outputs if the list contains an expression that outputs.



>>RUNRESULT instructionlist



	runs the instructions in the input; outputs an empty list if

	those instructions produce no output, or a list whose only

	member is the output from running the input instructionlist.

	Useful for inventing command-or-operation control structures:



		local "result

		make "result runresult [something]

		if emptyp :result [stop]

		output first :result



>>REPEAT num instructionlist



	command.  Runs the "instructionlist" repeatedly, "num" times.



>>FOREVER instructionlist



	command.  Runs the "instructionlist" repeatedly, until something

	inside the instructionlist (such as STOP or THROW) makes it stop.



>>REPCOUNT



	outputs the repetition count of the innermost current REPEAT or

	FOREVER, starting from 1.  If no REPEAT or FOREVER is active,

	outputs -1.



	The abbreviation # can be used for REPCOUNT unless the REPEAT is

	inside the template input to a higher order procedure such as

	FOREACH, in which case # has a different meaning.



>>IF tf instructionlist

(IF tf instructionlist1 instructionlist2)



	command.  If the first input has the value TRUE, then IF runs

	the second input.  If the first input has the value FALSE, then

	IF does nothing.  (If given a third input, IF acts like IFELSE,

	as described below.)  It is an error if the first input is not

	either TRUE or FALSE.



	For compatibility with earlier versions of Logo, if an IF

	instruction is not enclosed in parentheses, but the first thing

	on the instruction line after the second input expression is a

	literal list (i.e., a list in square brackets), the IF is

	treated as if it were IFELSE, but a warning message is given.

	If this aberrant IF appears in a procedure body, the warning is

	given only the first time the procedure is invoked in each Logo

	session.



>>IFELSE tf instructionlist1 instructionlist2



	command or operation.  If the first input has the value TRUE, then

	IFELSE runs the second input.  If the first input has the value FALSE,

	then IFELSE runs the third input.  IFELSE outputs a value if the

	instructionlist contains an expression that outputs a value.



>>TEST tf



	command.  Remembers its input, which must be TRUE or FALSE, for use

	by later IFTRUE or IFFALSE instructions.  The effect of TEST is local

	to the procedure in which it is used; any corresponding IFTRUE or

	IFFALSE must be in the same procedure or a subprocedure.



>>IFTRUE instructionlist

IFT instructionlist



	command.  Runs its input if the most recent TEST instruction had

	a TRUE input.  The TEST must have been in the same procedure or a

	superprocedure.



>>IFFALSE instructionlist

IFF instructionlist



	command.  Runs its input if the most recent TEST instruction had

	a FALSE input.  The TEST must have been in the same procedure or a

	superprocedure.



>>STOP



	command.  Ends the running of the procedure in which it appears.

	Control is returned to the context in which that procedure was

	invoked.  The stopped procedure does not output a value.



>>OUTPUT/OP value



	command.  Ends the running of the procedure in which it appears.

	That procedure outputs the value "value" to the context in which

	it was invoked.  Don't be confused: OUTPUT itself is a command,

	but the procedure that invokes OUTPUT is an operation.



>>CATCH tag instructionlist



	command or operation.  Runs its second input.  Outputs if that

	instructionlist outputs.  If, while running the instructionlist,

	a THROW instruction is executed with a tag equal to the first

	input (case-insensitive comparison), then the running of the

	instructionlist is terminated immediately.  In this case the CATCH

	outputs if a value input is given to THROW.  The tag must be a word.



	If the tag is the word ERROR, then any error condition that arises

	during the running of the instructionlist has the effect of THROW

	"ERROR instead of printing an error message and returning to

	toplevel.  The CATCH does not output if an error is caught.  Also,

	during the running of the instructionlist, the variable ERRACT is

	temporarily unbound.  (If there is an error while ERRACT has a

	value, that value is taken as an instructionlist to be run after

	printing the error message.  Typically the value of ERRACT, if any,

	is the list [PAUSE].)



>>THROW tag

(THROW tag value)



	command.  Must be used within the scope of a CATCH with an equal

	tag.  Ends the running of the instructionlist of the CATCH.  If

	THROW is used with only one input, the corresponding CATCH does

	not output a value.  If THROW is used with two inputs, the second

	provides an output for the CATCH.



	THROW "TOPLEVEL can be used to terminate all running procedures and

	interactive pauses, and return to the toplevel instruction prompt.

	Typing the system interrupt character (alt-S for wxWidgets; otherwise

	normally control-C for Unix, control-Q for DOS, or command-period for

	Mac) has the same effect.



	THROW "ERROR can be used to generate an error condition.  If the

	error is not caught, it prints a message (THROW "ERROR) with the

	usual indication of where the error (in this case the THROW)

	occurred.  If a second input is used along with a tag of ERROR,

	that second input is used as the text of the error message

	instead of the standard message.  Also, in this case, the location

	indicated for the error will be, not the location of the THROW,

	but the location where the procedure containing the THROW was

	invoked.  This allows user-defined procedures to generate error

	messages as if they were primitives.  Note: in this case the

	corresponding CATCH "ERROR, if any, does not output, since the second

	input to THROW is not considered a return value.



	THROW "SYSTEM immediately leaves Logo, returning to the operating

	system, without printing the usual parting message and without

	deleting any editor temporary file written by EDIT.



>>ERROR



	outputs a list describing the error just caught, if any.  If there was

	not an error caught since the last use of ERROR, the empty list will

	be output.  The error list contains four members: an integer code

	corresponding to the type of error, the text of the error message (as

	a single word including spaces), the name of the procedure in which

	the error occurred, and the instruction line on which the error

	occurred.



>>PAUSE



	command or operation.  Enters an interactive pause.  The user is

	prompted for instructions, as at toplevel, but with a prompt that

	includes the name of the procedure in which PAUSE was invoked.

	Local variables of that procedure are available during the pause.

	PAUSE outputs if the pause is ended by a CONTINUE with an input.



	If the variable ERRACT exists, and an error condition occurs, the

	contents of that variable are run as an instructionlist.  Typically

	ERRACT is given the value [PAUSE] so that an interactive pause will

	be entered in the event of an error.  This allows the user to check

	values of local variables at the time of the error.



	Typing the system quit character (alt-S for wxWidgets; otherwise

	normally control-\ for Unix, control-W for DOS, or command-comma for

	Mac) will also enter a pause.



>>CONTINUE/CO value



(CONTINUE/CO)



	command.  Ends the current interactive pause, returning to the

	context of the PAUSE invocation that began it.  If CONTINUE is

	given an input, that value is used as the output from the PAUSE.

	If not, the PAUSE does not output.



	Exceptionally, the CONTINUE command can be used without its default

	input and without parentheses provided that nothing follows it on

	the instruction line.



>>WAIT time



	command.  Delays further execution for "time" 60ths of a second.

	Also causes any buffered characters destined for the terminal to

	be printed immediately.  WAIT 0 can be used to achieve this

	buffer flushing without actually waiting.



>>BYE



	command.  Exits from Logo; returns to the operating system.



>>.MAYBEOUTPUT value					(special form)



	works like OUTPUT except that the expression that provides the

	input value might not, in fact, output a value, in which case

	the effect is like STOP.  This is intended for use in control

	structure definitions, for cases in which you don't know whether

	or not some expression produces a value.  Example:



		to invoke :function [:inputs] 2

		.maybeoutput apply :function :inputs

		end



		? (invoke "print "a "b "c)

		a b c

		? print (invoke "word "a "b "c)

		abc



	This is an alternative to RUNRESULT.  It's fast and easy to use,

	at the cost of being an exception to Logo's evaluation rules.

	(Ordinarily, it should be an error if the expression that's

	supposed to provide an input to something doesn't have a value.)



>>GOTO word



	command.  Looks for a TAG command with the same input in the same

	procedure, and continues running the procedure from the location of

	that TAG.  It is meaningless to use GOTO outside of a procedure.



>>TAG quoted.word



	command.  Does nothing.  The input must be a literal word following

	a quotation mark ("), not the result of a computation.  Tags are

	used by the GOTO command.



>>IGNORE value						(library procedure)



	command.  Does nothing.  Used when an expression is evaluated for

	a side effect and its actual value is unimportant.



>>` list							(library procedure)



	outputs a list equal to its input but with certain substitutions.

	If a member of the input list is the word "," (comma) then the

	following member should be an instructionlist that produces an

	output when run.  That output value replaces the comma and the

	instructionlist.  If a member of the input list is the word ",@"

	(comma atsign) then the following member should be an instructionlist

	that outputs a list when run.  The members of that list replace the

	,@ and the instructionlist.  Example:



		show `[foo baz ,[bf [a b c]] garply ,@[bf [a b c]]]



	will print



		[foo baz [b c] garply b c]



	A word starting with , or ,@ is treated as if the rest of the word

	were a one-word list, e.g., ,:FOO is equivalent to ,[:FOO].



	A word starting with ", (quote comma) or :, (colon comma) becomes a

	word starting with " or : but with the result of running the

	substitution (or its first word, if the result is a list) replacing

	what comes after the comma.



	Backquotes can be nested.  Substitution is done only for commas at

	the same depth as the backquote in which they are found:



		? show `[a `[b ,[1+2] ,[foo ,[1+3] d] e] f]

		[a ` [b , [1+2] , [foo 4 d] e] f]



		?make "name1 "x

		?make "name2 "y

		? show `[a `[b ,:,:name1 ,",:name2 d] e]

		[a ` [b , [:x] , ["y] d] e]



>>FOR forcontrol instructionlist				(library procedure)



	command.  The first input must be a list containing three or four

	members: (1) a word, which will be used as the name of a local

	variable; (2) a word or list that will be evaluated as by RUN to

	determine a number, the starting value of the variable; (3) a word

	or list that will be evaluated to determine a number, the limit value

	of the variable; (4) an optional word or list that will be evaluated

	to determine the step size.  If the fourth member is missing, the

	step size will be 1 or -1 depending on whether the limit value is

	greater than or less than the starting value, respectively.



	The second input is an instructionlist.  The effect of FOR is to run

	that instructionlist repeatedly, assigning a new value to the control

	variable (the one named by the first member of the forcontrol list)

	each time.  First the starting value is assigned to the control

	variable.  Then the value is compared to the limit value.  FOR is

	complete when the sign of (current - limit) is the same as the sign

	of the step size.  (If no explicit step size is provided, the

	instructionlist is always run at least once.  An explicit step size

	can lead to a zero-trip FOR, e.g., FOR [I 1 0 1] ...)  Otherwise, the

	instructionlist is run, then the step is added to the current value

	of the control variable and FOR returns to the comparison step.



		? for [i 2 7 1.5] [print :i]

		2

		3.5

		5

		6.5

		?



>>DO.WHILE instructionlist tfexpression			(library procedure)



	command.  Repeatedly evaluates the "instructionlist" as long as the

	evaluated "tfexpression" remains TRUE.  Evaluates the first input

	first, so the "instructionlist" is always run at least once.  The

	"tfexpression" must be an expressionlist whose value when evaluated

	is TRUE or FALSE.



>>WHILE tfexpression instructionlist			(library procedure)



	command.  Repeatedly evaluates the "instructionlist" as long as the

	evaluated "tfexpression" remains TRUE.  Evaluates the first input

	first, so the "instructionlist" may never be run at all.  The

	"tfexpression" must be an expressionlist whose value when evaluated

	is TRUE or FALSE.



>>DO.UNTIL instructionlist tfexpression			(library procedure)



	command.  Repeatedly evaluates the "instructionlist" as long as the

	evaluated "tfexpression" remains FALSE.  Evaluates the first input

	first, so the "instructionlist" is always run at least once.  The

	"tfexpression" must be an expressionlist whose value when evaluated

	is TRUE or FALSE.



>>UNTIL tfexpression instructionlist			(library procedure)



	command.  Repeatedly evaluates the "instructionlist" as long as the

	evaluated "tfexpression" remains FALSE.  Evaluates the first input

	first, so the "instructionlist" may never be run at all.  The

	"tfexpression" must be an expressionlist whose value when evaluated

	is TRUE or FALSE.



>>CASE value clauses					(library procedure)



	command or operation.  The second input is a list of lists (clauses);

	each clause is a list whose first element is either a list of values

	or the word ELSE and whose butfirst is a Logo expression or

	instruction.  CASE examines the clauses in order.  If a clause begins

	with the word ELSE (upper or lower case), then the butfirst of that

	clause is evaluated and CASE outputs its value, if any.  If the first

	input to CASE is a member of the first element of a clause, then the

	butfirst of that clause is evaluated and CASE outputs its value, if

	any.  If neither of these conditions is met, then CASE goes on to the

	next clause.  If no clause is satisfied, CASE does nothing.  Example:



		to vowelp :letter

		output case :letter [ [[a e i o u] "true] [else "false] ]

		end



>>COND clauses						(library procedure)



	command or operation.  The input is a list of lists (clauses); each

	clause is a list whose first element is either an expression whose

	value is TRUE or FALSE, or the word ELSE, and whose butfirst is a Logo

	expression or instruction.  COND examines the clauses in order.  If a

	clause begins with the word ELSE (upper or lower case), then the

	butfirst of that clause is evaluated and CASE outputs its value, if

	any.  Otherwise, the first element of the clause is evaluated; the

	resulting value must be TRUE or FALSE.  If it's TRUE, then the

	butfirst of that clause is evaluated and COND outputs its value, if

	any.  If the value is FALSE, then COND goes on to the next clause.  If

	no clause is satisfied, COND does nothing.  Example:



		to evens :numbers	; select even numbers from a list

		op cond [ [[emptyp :numbers] []]

		          [[evenp first :numbers]  ; assuming EVENP is defined

		           fput first :numbers evens butfirst :numbers]

		          [else evens butfirst :numbers] ]

		end





///TEMPLATE-BASED ITERATION





>>The procedures in this section are iteration tools based on the idea of a

"template."  This is a generalization of an instruction list or an

expression list in which "slots" are provided for the tool to insert varying

data.  Four different forms of template can be used.



The most commonly used form for a template is "explicit-slot" form, or

"question mark" form.  Example:



	? show map [? * ?] [2 3 4 5]

	[4 9 16 25]

	?



In this example, the MAP tool evaluated the template [? * ?] repeatedly,

with each of the members of the data list [2 3 4 5] substituted in turn

for the question marks.  The same value was used for every question mark

in a given evaluation.  Some tools allow for more than one datum to be

substituted in parallel; in these cases the slots are indicated by ?1 for

the first datum, ?2 for the second, and so on:



	? show (map [(word ?1 ?2 ?1)] [a b c] [d e f])

	[ada beb cfc]

	?



If the template wishes to compute the datum number, the form (? 1) is

equivalent to ?1, so (? ?1) means the datum whose number is given in

datum number 1.  Some tools allow additional slot designations, as shown

in the individual descriptions.



The second form of template is the "named-procedure" form.  If the template

is a word rather than a list, it is taken as the name of a procedure.  That

procedure must accept a number of inputs equal to the number of parallel

data slots provided by the tool; the procedure is applied to all of the

available data in order.  That is, if data ?1 through ?3 are available,

the template "PROC is equivalent to [PROC ?1 ?2 ?3].



	? show (map "word [a b c] [d e f])

	[ad be cf]

	?



	to dotprod :a :b	; vector dot product

	op apply "sum (map "product :a :b)

	end



The third form of template is "named-slot" or "lambda" form.  This form is

indicated by a template list containing more than one member, whose first

member is itself a list.  The first member is taken as a list of names;

local variables are created with those names and given the available data

in order as their values.  The number of names must equal the number of

available data.  This form is needed primarily when one iteration tool must

be used within the template list of another, and the ? notation would be

ambiguous in the inner template.  Example:



	to matmul :m1 :m2 [:tm2 transpose :m2]	; multiply two matrices

	output map [[row] map [[col] dotprod :row :col] :tm2] :m1

	end



The fourth form is "procedure text" form, a variant of lambda form.  In this

form, the template list contains at least two members, all of which are

lists.  This is the form used by the DEFINE and TEXT primitives, and APPLY

accepts it so that the text of a defined procedure can be used as a template.



Note:  The fourth form of template is interpreted differently from the

others, in that Logo considers it to be an independent defined procedure

for the purposes of OUTPUT and STOP.  For example, the following two

instructions are identical:



	? print apply [[x] :x+3] [5]

	8

	? print apply [[x] [output :x+3]] [5]

	8



although the first instruction is in named-slot form and the second is

in procedure-text form.  The named-slot form can be understood as telling

Logo to evaluate the expression :x+3 in place of the entire invocation of

apply, with the variable x temporarily given the value 5.  The procedure-text

form can be understood as invoking the procedure



	to foo :x

	output :x+3

	end



with input 5, but without actually giving the procedure a name.  If

the use of OUTPUT were interchanged in these two examples, we'd get errors:



	? print apply [[x] output :x+3] [5]

	Can only use output inside a procedure

	? print apply [[x] [:x+3]] [5]

	You don't say what to do with 8



The named-slot form can be used with STOP or OUTPUT inside a procedure,

to stop the enclosing procedure.





The following iteration tools are extended versions of the ones in Appendix

B of the book _Computer_Science_Logo_Style,_Volume_3:_Advanced_Topics_ by

Brian Harvey [MIT Press, 1987].  The extensions are primarily to allow for

variable numbers of inputs.





>>APPLY template inputlist



	command or operation.  Runs the "template," filling its slots with

	the members of "inputlist."  The number of members in "inputlist"

	must be an acceptable number of slots for "template."  It is

	illegal to apply the primitive TO as a template, but anything else

	is okay.  APPLY outputs what "template" outputs, if anything.



>>INVOKE template input					(library procedure)

(INVOKE template input1 input2 ...)



	command or operation.  Exactly like APPLY except that the inputs

	are provided as separate expressions rather than in a list.



>>FOREACH data template					(library procedure)

(FOREACH data1 data2 ... template)



	command.  Evaluates the template list repeatedly, once for each

	member of the data list.  If more than one data list are given,

	each of them must be the same length.  (The data inputs can be

	words, in which case the template is evaluated once for each

	character.)



	In a template, the symbol ?REST represents the portion of the

	data input to the right of the member currently being used as

	the ? slot-filler.  That is, if the data input is [A B C D E]

	and the template is being evaluated with ? replaced by B, then

	?REST would be replaced by [C D E].  If multiple parallel slots

	are used, then (?REST 1) goes with ?1, etc.



	In a template, the symbol # represents the position in the data

	input of the member currently being used as the ? slot-filler.

	That is, if the data input is [A B C D E] and the template is

	being evaluated with ? replaced by B, then # would be replaced

	by 2.



>>MAP template data					(library procedure)

(MAP template data1 data2 ...)



	outputs a word or list, depending on the type of the data input,

	of the same length as that data input.  (If more than one data

	input are given, the output is of the same type as data1.)  Each

	member of the output is the result of evaluating the template

	list, filling the slots with the corresponding member(s) of the

	data input(s).  (All data inputs must be the same length.)  In the

	case of a word output, the results of the template evaluation must

	be words, and they are concatenated with WORD.



	In a template, the symbol ?REST represents the portion of the

	data input to the right of the member currently being used as

	the ? slot-filler.  That is, if the data input is [A B C D E]

	and the template is being evaluated with ? replaced by B, then

	?REST would be replaced by [C D E].  If multiple parallel slots

	are used, then (?REST 1) goes with ?1, etc.



	In a template, the symbol # represents the position in the data

	input of the member currently being used as the ? slot-filler.

	That is, if the data input is [A B C D E] and the template is

	being evaluated with ? replaced by B, then # would be replaced

	by 2.



>>MAP.SE template data					(library procedure)

(MAP.SE template data1 data2 ...)



	outputs a list formed by evaluating the template list repeatedly

	and concatenating the results using SENTENCE.  That is, the

	members of the output are the members of the results of the

	evaluations.  The output list might, therefore, be of a different

	length from that of the data input(s).  (If the result of an

	evaluation is the empty list, it contributes nothing to the final

	output.)  The data inputs may be words or lists.



	In a template, the symbol ?REST represents the portion of the

	data input to the right of the member currently being used as

	the ? slot-filler.  That is, if the data input is [A B C D E]

	and the template is being evaluated with ? replaced by B, then

	?REST would be replaced by [C D E].  If multiple parallel slots

	are used, then (?REST 1) goes with ?1, etc.



	In a template, the symbol # represents the position in the data

	input of the member currently being used as the ? slot-filler.

	That is, if the data input is [A B C D E] and the template is

	being evaluated with ? replaced by B, then # would be replaced

	by 2.



>>FILTER tftemplate data					(library procedure)



	outputs a word or list, depending on the type of the data input,

	containing a subset of the members (for a list) or characters (for

	a word) of the input.  The template is evaluated once for each

	member or character of the data, and it must produce a TRUE or

	FALSE value.  If the value is TRUE, then the corresponding input

	constituent is included in the output.



		? print filter "vowelp "elephant

		eea

		?



	In a template, the symbol ?REST represents the portion of the

	data input to the right of the member currently being used as

	the ? slot-filler.  That is, if the data input is [A B C D E]

	and the template is being evaluated with ? replaced by B, then

	?REST would be replaced by [C D E].



	In a template, the symbol # represents the position in the data

	input of the member currently being used as the ? slot-filler.

	That is, if the data input is [A B C D E] and the template is

	being evaluated with ? replaced by B, then # would be replaced

	by 2.



>>FIND tftemplate data					(library procedure)



	outputs the first constituent of the data input (the first member

	of a list, or the first character of a word) for which the value

	produced by evaluating the template with that consituent in its

	slot is TRUE.  If there is no such constituent, the empty list

	is output.



	In a template, the symbol ?REST represents the portion of the

	data input to the right of the member currently being used as

	the ? slot-filler.  That is, if the data input is [A B C D E]

	and the template is being evaluated with ? replaced by B, then

	?REST would be replaced by [C D E].



	In a template, the symbol # represents the position in the data

	input of the member currently being used as the ? slot-filler.

	That is, if the data input is [A B C D E] and the template is

	being evaluated with ? replaced by B, then # would be replaced

	by 2.



>>REDUCE template data					(library procedure)



	outputs the result of applying the template to accumulate the

	members of the data input.  The template must be a two-slot

	function.  Typically it is an associative function name like SUM.

	If the data input has only one constituent (member in a list or

	character in a word), the output is that consituent.  Otherwise,

	the template is first applied with ?1 filled with the next-to-last

	consitient and ?2 with the last constituent.  Then, if there are

	more constituents, the template is applied with ?1 filled with the

	next constituent to the left and ?2 with the result from the

	previous evaluation.  This process continues until all constituents

	have been used.  The data input may not be empty.



	Note: If the template is, like SUM, the name of a procedure that is

	capable of accepting arbitrarily many inputs, it is more efficient

	to use APPLY instead of REDUCE.  The latter is good for associative

	procedures that have been written to accept exactly two inputs:



		to max :a :b

		output ifelse :a > :b [:a] [:b]

		end



		print reduce "max [...]



	Alternatively, REDUCE can be used to write MAX as a procedure

	that accepts any number of inputs, as SUM does:



		to max [:inputs] 2

		if emptyp :inputs ~

		   [(throw "error [not enough inputs to max])]

		output reduce [ifelse ?1 > ?2 [?1] [?2]] :inputs

		end



>>CROSSMAP template listlist				(library procedure)

(CROSSMAP template data1 data2 ...)



	outputs a list containing the results of template evaluations.

	Each data list contributes to a slot in the template; the number

	of slots is equal to the number of data list inputs.  As a special

	case, if only one data list input is given, that list is taken as

	a list of data lists, and each of its members contributes values

	to a slot.  CROSSMAP differs from MAP in that instead of taking

	members from the data inputs in parallel, it takes all possible

	combinations of members of data inputs, which need not be the same

	length.



		? show (crossmap [word ?1 ?2] [a b c] [1 2 3 4])

		[a1 a2 a3 a4 b1 b2 b3 b4 c1 c2 c3 c4]

		?



	For compatibility with the version in the first edition of CSLS,

	CROSSMAP templates may use the notation :1 instead of ?1 to indicate

	slots.



>>CASCADE endtest template startvalue			(library procedure)

(CASCADE endtest tmp1 sv1 tmp2 sv2 ...)

(CASCADE endtest tmp1 sv1 tmp2 sv2 ... finaltemplate)



	outputs the result of applying a template (or several templates,

	as explained below) repeatedly, with a given value filling the

	slot the first time, and the result of each application filling

	the slot for the following application.



	In the simplest case, CASCADE has three inputs.  The second input

	is a one-slot expression template.  That template is evaluated

	some number of times (perhaps zero).  On the first evaluation,

	the slot is filled with the third input; on subsequent evaluations,

	the slot is filled with the result of the previous evaluation.

	The number of evaluations is determined by the first input.  This

	can be either a nonnegative integer, in which case the template is

	evaluated that many times, or a predicate expression template, in

	which case it is evaluated (with the same slot filler that will be

	used for the evaluation of the second input) repeatedly, and the

	CASCADE evaluation continues as long as the predicate value is

	FALSE.  (In other words, the predicate template indicates the

	condition for stopping.)



	If the template is evaluated zero times, the output from CASCADE

	is the third (startvalue) input.  Otherwise, the output is the

	value produced by the last template evaluation.



	CASCADE templates may include the symbol # to represent the number

	of times the template has been evaluated.  This slot is filled with

	1 for the first evaluation, 2 for the second, and so on.



		? show cascade 5 [lput # ?] []

		[1 2 3 4 5]

		? show cascade [vowelp first ?] [bf ?] "spring

		ing

		? show cascade 5 [# * ?] 1

		120

		?



	Several cascaded results can be computed in parallel by providing

	additional template-startvalue pairs as inputs to CASCADE.  In this

	case, all templates (including the endtest template, if used) are

	multi-slot, with the number of slots equal to the number of pairs of

	inputs.  In each round of evaluations, ?2, for example, represents the

	result of evaluating the second template in the previous round.  If

	the total number of inputs (including the first endtest input) is odd,

	then the output from CASCADE is the final value of the first template.

	If the total number of inputs is even, then the last input is a

	template that is evaluated once, after the end test is satisfied, to

	determine the output from CASCADE.



		to fibonacci :n

		output (cascade :n [?1 + ?2] 1 [?1] 0)

		end



		to piglatin :word

		output (cascade [vowelp first ?] ~

				[word bf ? first ?] ~

				:word ~

				[word ? "ay])

		end



>>CASCADE.2 endtest temp1 startval1 temp2 startval2	(library procedure)



	outputs the result of invoking CASCADE with the same inputs.

	The only difference is that the default number of inputs is

	five instead of three.



>>TRANSFER endtest template inbasket			(library procedure)



	outputs the result of repeated evaluation of the template.

	The template is evaluated once for each member of the list

	"inbasket."  TRANSFER maintains an "outbasket" that is

	initially the empty list.  After each evaluation of the

	template, the resulting value becomes the new outbasket.



	In the template, the symbol ?IN represents the current member

	from the inbasket; the symbol ?OUT represents the entire

	current outbasket.  Other slot symbols should not be used.



	If the first (endtest) input is an empty list, evaluation

	continues until all inbasket members have been used.  If not,

	the first input must be a predicate expression template, and

	evaluation continues until either that template's value is TRUE

	or the inbasket is used up.





///MACROS



>>.MACRO procname :input1 :input2 ...				(special form)

.DEFMACRO procname text



	A macro is a special kind of procedure whose output is evaluated

	as Logo instructions in the context of the macro's caller.

	.MACRO is exactly like TO except that the new procedure becomes

	a macro; .DEFMACRO is exactly like DEFINE with the same exception.



	Macros are useful for inventing new control structures comparable

	to REPEAT, IF, and so on.  Such control structures can almost, but

	not quite, be duplicated by ordinary Logo procedures.  For example,

	here is an ordinary procedure version of REPEAT:



		to my.repeat :num :instructions

		if :num=0 [stop]

		run :instructions

		my.repeat :num-1 :instructions

		end



	This version works fine for most purposes, e.g.,



		my.repeat 5 [print "hello]



	But it doesn't work if the instructions to be carried out include

	OUTPUT, STOP, or LOCAL.  For example, consider this procedure:



		to example

		print [Guess my secret word.  You get three guesses.]

		repeat 3 [type "|?? | ~

			  if readword = "secret [pr "Right! stop]]

		print [Sorry, the word was "secret"!]

		end



	This procedure works as written, but if MY.REPEAT is used instead

	of REPEAT, it won't work because the STOP will stop MY.REPEAT

	instead of stopping EXAMPLE as desired.



	The solution is to make MY.REPEAT a macro.  Instead of actually

	carrying out the computation, a macro must return a list containing

	Logo instructions.  The contents of that list are evaluated as if

	they appeared in place of the call to the macro.  Here's a macro

	version of REPEAT:



		.macro my.repeat :num :instructions

		if :num=0 [output []]

		output sentence :instructions ~

				(list "my.repeat :num-1 :instructions)

		end



	Every macro is an operation -- it must always output something.

	Even in the base case, MY.REPEAT outputs an empty instruction

	list.  To show how MY.REPEAT works, let's take the example



		my.repeat 5 [print "hello]



	For this example, MY.REPEAT will output the instruction list



		[print "hello my.repeat 4 [print "hello]]



	Logo then executes these instructions in place of the original

	invocation of MY.REPEAT; this prints "hello" once and invokes

	another repetition.



	The technique just shown, although fairly easy to understand,

	has the defect of slowness because each repetition has to

	construct an instruction list for evaluation.  Another approach

	is to make MY.REPEAT a macro that works just like the non-macro

	version unless the instructions to be repeated include OUTPUT

	or STOP:



		.macro my.repeat :num :instructions

		catch "repeat.catchtag ~

		      [op repeat.done runresult [repeat1 :num :instructions]]

		op []

		end



		to repeat1 :num :instructions

		if :num=0 [throw "repeat.catchtag]

		run :instructions

		.maybeoutput repeat1 :num-1 :instructions

		end



		to repeat.done :repeat.result

		if emptyp :repeat.result [op [stop]]

		op list "output quoted first :repeat.result

		end



	If the instructions do not include STOP or OUTPUT, then REPEAT1 will

	reach its base case and invoke THROW.  As a result, MY.REPEAT's last

	instruction line will output an empty list, so the evaluation of the

	macro result by the caller will do nothing.  But if a STOP or OUTPUT

	happens, then REPEAT.DONE will output a STOP or OUTPUT instruction

	that will be executed in the caller's context.



	The macro-defining commands have names starting with a dot because

	macros are an advanced feature of Logo; it's easy to get in trouble

	by defining a macro that doesn't terminate, or by failing to

	construct the instruction list properly.



	Lisp users should note that Logo macros are NOT special forms.

	That is, the inputs to the macro are evaluated normally, as they

	would be for any other Logo procedure.  It's only the output from

	the macro that's handled unusually.



	Here's another example:



		.macro localmake :name :value

		output (list "local		~

			     word "" :name	~

			     "apply		~

			     ""make		~

			     (list :name :value))

		end



	It's used this way:



		to try

		localmake "garply "hello

		print :garply

		end



	LOCALMAKE outputs the list



		[local "garply apply "make [garply hello]]



	The reason for the use of APPLY is to avoid having to decide

	whether or not the second input to MAKE requires a quotation

	mark before it.  (In this case it would -- MAKE "GARPLY "HELLO --

	but the quotation mark would be wrong if the value were a list.)



	It's often convenient to use the ` function to construct the

	instruction list:



		.macro localmake :name :value

		op `[local ,[word "" :name] apply "make [,[:name] ,[:value]]]

		end



	On the other hand, ` is pretty slow, since it's tree recursive and

	written in Logo.



>>MACROP name

MACRO? name



	outputs TRUE if its input is the name of a macro.



>>MACROEXPAND expr					(library procedure)



	takes as its input a Logo expression that invokes a macro (that is,

	one that begins with the name of a macro) and outputs the the Logo

	expression into which the macro would translate the input expression.





		.macro localmake :name :value

		op `[local ,[word "" :name] apply "make [,[:name] ,[:value]]]

		end



		? show macroexpand [localmake "pi 3.14159]

		[local "pi apply "make [pi 3.14159]]


